import time
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from aesLongKeyGen16 import *

# Read messages from file
with open("2aesPlaintexts.txt", "r") as reader:
    messages = reader.read().split('\n')
    
with open("2aesCiphertexts.txt", "r") as ciphers_file:
    ciphers = ciphers_file.read().split('\n')

# Sets to store unique cipher representations after encryption
cipher_set = set()   
cipher_set_dash = set()

# Dictionaries to map cipher representations to short keys
cipher_dic = {}
cipher_dic_dash = {}

# Initialization Vector (IV) for Cipher Block Chaining (CBC) mode
iv = b'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'

start_time = time.time()

#  This function is doing AES encryption
def AES_enc(key, message):
    cipher_instance = Cipher(algorithms.AES(key), modes.CBC(iv))
    encryptor = cipher_instance.encryptor()
    ciphertext = encryptor.update(message) + encryptor.finalize()
    return ciphertext

#  This function is doing AES decryption
def AES_dec(key, cipher_text):
    cipher_instance = Cipher(algorithms.AES(key), modes.CBC(iv))
    decryptor = cipher_instance.decryptor()
    plaintext = decryptor.update(cipher_text)+decryptor.finalize()
    return plaintext


byte_combinations = []

# Iterate through all possible combinations of two bytes (0 to 255)
for byte1 in range(256):
    for byte2 in range(256):
            byte_combinations.append(bytes([byte1, byte2]))

print(f"Take a deep breathe....\nProgramme is running.....\n")
# Iterate through all generated byte combinations
for j in range(0, len(byte_combinations)):
    shortKey = bytearray(byte_combinations[j])
    key = expandKey(shortKey)
    # Encrypt the message at index 0 using the key
    cipher1 = AES_enc(key, messages[0].encode('UTF-8'))
    cipher_set.add(cipher1.hex())
    cipher_dic[cipher1.hex()] = shortKey.hex()
    
    # Decrypt the cipher at index 0 using the same key
    cipher1dash = AES_dec(key, bytes.fromhex(ciphers[0]))
    cipher_set_dash.add((cipher1dash.hex()))
    cipher_dic_dash[cipher1dash.hex()] = shortKey.hex()
    
    
# print("\nAll possible keys are used for encryption and decryption and stored.\n")
# print("\nNow we will compare the result to get correct key pair.\n")
    

def check_for_other_messages(sk1, sk2):
    # Convert the hexadecimal short keys to bytes
    shortKey1 = bytes.fromhex(sk1)
    key1 = expandKey(shortKey1)
    shortKey2 = bytes.fromhex(sk2)
    key2 = expandKey(shortKey2)
    # Iterate through all messages and their corresponding ciphers
    for i,message in enumerate(messages):
        # Encrypt the message using the first key
        cipher1 = AES_enc(key1, message.encode('UTF-8'))
        # Encrypt the result using the second key
        cipher2 = AES_enc(key2, cipher1)
        # Check if the final cipher matches the expected cipher for the current message
        if cipher2.hex() == ciphers[i]:
            # print(f"verified for message {i+1}")
            continue
        else:
            return 0
    return 1
        
# Iterate through the set of unique cipher representations obtained from encryption
for cip in cipher_set:
    # Check if the cipher representation is also present in the set obtained from decryption
    if cip in cipher_set_dash:
          # Retrieve the short keys corresponding to the matching cipher from the dictionaries
        key1 = cipher_dic[cip]
        key2 = cipher_dic_dash[cip]
        # print(f"Match found for ciphertext: {cip}")
        print(f"Fist short key: {key1}")
        print(f"Second short key: {key2}")
        # print("\nChecking for other messages....\n")
        
        # Call the function to check for other messages using the found short keys
        if check_for_other_messages(key1, key2):
            print("\nVerified for all the messages.\n")
        else:
            print("Not matching for other message!!!")
        


print("\nDecrypting last message with found key pair....")
# finding 5th message

# Expand the short keys to obtain the full AES keys
long_key1 = expandKey(bytes.fromhex(key1))
long_key2 = expandKey(bytes.fromhex(key2))

# Decrypt the last ciphertext using the second long key
cipher1_5th = AES_dec(long_key2, bytes.fromhex(ciphers[-1]))  # Remove encode('UTF-8') here

# Decrypt the result using the first long key to obtain the original message
message_5th = AES_dec(long_key1, cipher1_5th)

message_5th_str = str(message_5th.decode())
print(f"\nThe secret message is : {(message_5th_str)} \n")

# Write the decrypted message to a file
with open("2aesSecretMessage.txt", "w") as secret_file:
        secret_file.write(message_5th_str)
        print("Written secret message in 2aesSecretMessage.txt file\n")


end_time = time.time()
running_time = end_time - start_time
print(f"Running time : {running_time}")